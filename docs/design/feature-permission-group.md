# 设计文档：基于用户组的统一权限模型

本文档详细阐述了框架的权限模型。该模型通过一个统一的、基于“用户组”的RBAC（Role-Based Access Control）机制，结合一个特殊的“系统组”来管理所有权限。

## 1. 核心思想：用户组与系统组

本模型的核心思想是 **“所有权限都通过组来管理”**。系统中存在两种类型的组：

*   **用户组 (User Groups)**: 用于管理项目、团队或任何资源集合的协作空间。每个用户组都是一个独立的权限域，可以拥有自己的成员和角色分配。例如，一个“项目A”组和一个“市场团队”组。
*   **系统组 (System Group)**: 数据库初始化时会有一个特殊的、id为 `00000000-0000-0000-0000-000000000001` 的组，专门用于管理整个系统的管理员。这个组里面初始化时会创建一个`Admin`的角色关联这管理员的权限。任何用户一旦被加入此组并赋予这些权限，便获得了全局管理权限。

这个设计的优势在于**模型统一**。所有权限检查都遵循同一套逻辑：**检查当前用户在目标组内是否拥有所需权限，如果没有，则回退检查其是否在系统组中拥有该权限。**

## 2. 数据库结构设计

为了支撑这个统一模型，我们采用了一套简化的、基于模板角色的RBAC表结构。

#### **2.1 核心表**

*   `groups`: 存储所有组的信息 (`id`, `name`, `description`)。
*   `permissions`: 存储所有原子化权限 (`id`, `name`, `description`)。
*   `roles`: 定义角色 (`id`, `group_id`, `name`, `description`)。`group_id` 为 `NULL` 的角色是可被所有组使用的“全局角色模板”。
*   `role_permissions`: 关联 `roles` 和 `permissions`，为角色预设一组权限。
*   `group_users`: 将用户加入一个组，并赋予其一个角色 (`user_id`, `group_id`, `role_id`)。

与早期设计不同，现在**每个组不再定义自己独有的角色**。相反，在创建组或管理成员时，直接从预设的模板角色（如 `Owner`, `Member`）中选择一个赋予用户。

## 3. 模板角色 (`Owner` & `Member`)

为了简化组的管理，系统预定义了两个核心的模板角色：`Owner` 和 `Member`。

*   **Owner (所有者)**: 当一个用户创建一个新的用户组时，他会自动成为该组的 `Owner`。`Owner` 角色被授予了管理该组的所有权限，例如添加/移除成员、删除组、修改组信息等。
*   **Member (成员)**: 普通的组成员，拥有组内资源的基础操作权限（如读取、创建），但没有管理权限。

`database-initialization.sql` 脚本负责在系统初始化时创建这两个模板角色，并为它们分配合理的默认权限。

## 4. 核心权限检查逻辑 (`check_group_permission`)

这是所有RLS策略的核心依赖。它负责回答“当前用户是否对特定组的资源拥有特定权限”这个问题。其内部逻辑遵循以下步骤：

1.  **检查目标组**：首先，函数会检查当前用户是否在传入的目标组 (`p_group_id`) 中，通过其被赋予的角色，拥有所需的权限 (`p_permission_name`)。
2.  **成功则返回**：如果用户在目标组中拥有权限，函数立即返回 `true`，检查结束。
3.  **回退检查系统组**：如果在目标组中没有找到权限，函数会接着检查该用户是否在全局的“系统组”中拥有相同的权限（这通常意味着用户是系统管理员）。
4.  **最终结果**：如果用户在系统组中拥有权限，函数同样返回 `true`。如果两轮检查都失败，则返回 `false`。

这个包含了“回退检查”的统一逻辑，正是我们权限模型的核心。

## 5. 统一的RLS策略模型

为了进一步简化RLS策略的创建，框架提供了一个辅助函数 `create_rls_policy`。它封装了创建策略的样板代码，你只需要提供表名和所需的权限名即可。

**示例：`posts` 表的 `UPDATE` 策略**

```sql
-- 使用辅助函数为 posts 表的 UPDATE 操作创建 RLS 策略
SELECT create_rls_policy('posts', 'UPDATE');
```

这行代码会自动生成一个 `UPDATE` 策略，其内部依然是调用 `check_group_permission(posts.group_id, 'db.posts.update')`。这完美地诠释了模型的思想：当一个用户（无论是普通用户还是系统管理员）尝试更新 `posts` 表的某一行时，生成的策略会确保只有拥有 `db.posts.update` 权限的用户才能执行操作。

如果你的表使用的不是默认的 `group_id` 列名，你也可以在第三个参数中指定它：
```sql
-- 假设你的表使用 'project_id' 作为组ID列
SELECT create_rls_policy('tasks', 'UPDATE', p_group_id_column := 'project_id');
```

## 6. 总结

通过将权限管理统一到“用户组”和“系统组”这两个概念上，并利用可复用的“模板角色”和单一的 `check_group_permission` 检查函数，我们构建了一个内聚且高度可扩展的权限模型。它极大地简化了RLS策略的编写和维护，使得权限管理更加清晰和直观。