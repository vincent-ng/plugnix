# 设计文档：基于组织的统一权限模型

本文档详细阐述了框架的权限模型。该模型通过一个统一的、基于“组织”的RBAC（Role-Based Access Control）机制，结合一个特殊的“系统组织”来管理所有权限。

## 1. 核心思想：组织与系统组织

本模型的核心思想是 **“所有权限都通过组织来管理”**。系统中存在两种类型的组织：

*   **组织 (Tenants)**: 用于管理项目、团队或任何资源集合的协作空间。每个组织都是一个独立的权限域，可以拥有自己的成员和角色分配。例如，一个“项目A”组织和一个“市场团队”组织。
*   **系统组织 (System Tenant)**: 数据库初始化时会有一个特殊的、id为 `00000000-0000-0000-0000-000000000001` 的组织，专门用于管理整个系统的管理员。该组织初始化时会创建一个 `Admin` 角色关联系统级权限。任何用户一旦被加入此组织并赋予这些权限，便获得了全局管理权限。

这个设计的优势在于**模型统一**。所有权限检查都遵循同一套逻辑：**检查当前用户在目标组织内是否拥有所需权限，如果没有，则回退检查其是否在系统组织中拥有该权限。**

## 2. 数据库结构设计

为了支撑这个统一模型，我们采用了一套简化的、基于模板角色的RBAC表结构。

#### **2.1 核心表**

*   `tenants`: 存储所有组织的信息 (`id`, `name`, `description`)。
*   `permissions`: 存储所有原子化权限 (`id`, `name`, `description`)。
*   `roles`: 定义角色 (`id`, `tenant_id`, `name`, `description`)。`tenant_id` 为 `NULL` 的角色是可被所有组织使用的“全局角色模板”。
*   `role_permissions`: 关联 `roles` 和 `permissions`，为角色预设一组权限。
*   `tenant_users`: 将用户加入一个组织，并赋予其一个角色 (`user_id`, `tenant_id`, `role_id`)。

每个组织默认无需定义自己的角色。在创建组织或管理成员时，直接使用系统预设的模板角色（如 `Owner`, `Member`），组织管理员后续可以为组织创建新的角色，并自由分配权限。

## 3. 模板角色 (`Owner` & `Member`)

为了简化组织的管理，系统预定义了两个核心的模板角色：`Owner` 和 `Member`。

*   **Owner (所有者)**: 当一个用户创建一个新的组织时，他会自动成为该组织的 `Owner`。`Owner` 角色被授予了管理该组织的所有权限，例如添加/移除成员、删除组织、修改组织信息等。
*   **Member (成员)**: 普通的组织成员，拥有组织内资源的基础操作权限（如读取、创建），但没有管理权限。

`database-initialization.sql` 脚本负责在系统初始化时创建这两个模板角色，并为它们分配合理的默认权限。

## 4. 核心权限检查逻辑 (`check_tenant_permission`)

这是所有RLS策略的核心依赖。它负责回答“当前用户是否对特定组织的资源拥有特定权限”这个问题。其内部逻辑遵循以下步骤：

1.  **检查目标组织**：首先，函数会检查当前用户是否在传入的目标组织 (`p_tenant_id`) 中，通过其被赋予的角色，拥有所需的权限 (`p_permission_name`)。
2.  **成功则返回**：如果用户在目标组中拥有权限，函数立即返回 `true`，检查结束。
3.  **回退检查系统组织**：如果在目标组织中没有找到权限，函数会接着检查该用户是否在全局的“系统组织”中拥有相同的权限（这通常意味着用户是系统管理员）。
4.  **最终结果**：如果用户在系统组织中拥有权限，函数同样返回 `true`。如果两轮检查都失败，则返回 `false`。

这个包含了“回退检查”的统一逻辑，正是我们权限模型的核心。

## 5. 统一的RLS策略模型

为了进一步简化RLS策略的创建，框架提供了一个辅助函数 `create_rls_policy`。它封装了创建策略的样板代码，你只需要提供表名和所需的权限名即可。

**示例：`posts` 表的 `UPDATE` 策略**

```sql
-- 使用辅助函数为 posts 表的 UPDATE 操作创建 RLS 策略
SELECT create_rls_policy('posts', 'UPDATE');
```

这行代码会自动生成一个 `UPDATE` 策略，其内部依然是调用 `check_tenant_permission(posts.tenant_id, 'db.posts.update')`。这完美地诠释了模型的思想：当一个用户（无论是普通用户还是系统管理员）尝试更新 `posts` 表的某一行时，生成的策略会确保只有拥有 `db.posts.update` 权限的用户才能执行操作。

如果你的表使用的不是默认的 `tenant_id` 列名，你也可以在第三个参数中指定它：
```sql
-- 假设你的表使用 'tenant_id' 作为组织ID列
SELECT create_rls_policy('tasks', 'UPDATE', p_tenant_id_column := 'tenant_id');
```

## 6. 总结

通过将权限管理统一到“组织”和“系统组织”这两个概念上，并利用可复用的“模板角色”和单一的 `check_tenant_permission` 检查函数，我们构建了一个内聚且高度可扩展的权限模型。它极大地简化了RLS策略的编写和维护，使得权限管理更加清晰和直观。